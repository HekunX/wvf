(function(h,f){typeof exports=="object"&&typeof module<"u"?f(exports):typeof define=="function"&&define.amd?define(["exports"],f):(h=typeof globalThis<"u"?globalThis:h||self,f(h.webview={}))})(this,function(h){"use strict";h.DotNet=void 0,function(s){const i=[],d="__jsObjectId",y="__dotNetObject",w="__byte[]",k="__dotNetStream",$="__jsStreamReferenceLength";let p,u;class A{constructor(e){this._jsObject=e,this._cachedFunctions=new Map}findFunction(e){const t=this._cachedFunctions.get(e);if(t)return t;let r=this._jsObject,o;if(e.split(".").forEach(c=>{if(c in r)o=r,r=r[c];else throw new Error(`Could not find '${e}' ('${c}' was undefined).`)}),r instanceof Function)return r=r.bind(o),this._cachedFunctions.set(e,r),r;throw new Error(`The value '${e}' is not a function.`)}getWrappedObject(){return this._jsObject}}const O=0,g={[O]:new A(window)};g[O]._cachedFunctions.set("import",n=>(typeof n=="string"&&n.startsWith("./")&&(n=new URL(n.substr(2),document.baseURI).toString()),import(n)));let J=1;function x(n){const e=new z(n);return p===void 0?p=e:p&&(p=null),e}s.attachDispatcher=x;function F(n){i.push(n)}s.attachReviver=F;function L(n,e,...t){return C().invokeDotNetStaticMethod(n,e,...t)}s.invokeMethod=L;function U(n,e,...t){return C().invokeDotNetStaticMethodAsync(n,e,...t)}s.invokeMethodAsync=U;function v(n){if(n&&typeof n=="object"){g[J]=new A(n);const e={[d]:J};return J++,e}throw new Error(`Cannot create a JSObjectReference from the value '${n}'.`)}s.createJSObjectReference=v;function R(n){let e=-1;if(n instanceof ArrayBuffer&&(n=new Uint8Array(n)),n instanceof Blob)e=n.size;else if(n.buffer instanceof ArrayBuffer){if(n.byteLength===void 0)throw new Error(`Cannot create a JSStreamReference from the value '${n}' as it doesn't have a byteLength.`);e=n.byteLength}else throw new Error("Supplied value is not a typed array or blob.");const t={[$]:e};try{const r=v(n);t[d]=r[d]}catch{throw new Error(`Cannot create a JSStreamReference from the value '${n}'.`)}return t}s.createJSStreamReference=R;function K(n){const e=n&&n[d];typeof e=="number"&&M(e)}s.disposeJSObjectReference=K;function m(n,e){u=n;const t=e?JSON.parse(e,(r,o)=>i.reduce((c,l)=>l(r,c),o)):null;return u=void 0,t}function C(){if(p===void 0)throw new Error("No call dispatcher has been set.");if(p===null)throw new Error("There are multiple .NET runtimes present, so a default dispatcher could not be resolved. Use DotNetObject to invoke .NET instance methods.");return p}let D;(function(n){n[n.Default=0]="Default",n[n.JSObjectReference=1]="JSObjectReference",n[n.JSStreamReference=2]="JSStreamReference",n[n.JSVoidResult=3]="JSVoidResult"})(D=s.JSCallResultType||(s.JSCallResultType={}));class z{constructor(e){this._dotNetCallDispatcher=e,this._byteArraysToBeRevived=new Map,this._pendingDotNetToJSStreams=new Map,this._pendingAsyncCalls={},this._nextAsyncCallId=1}getDotNetCallDispatcher(){return this._dotNetCallDispatcher}invokeJSFromDotNet(e,t,r,o){const c=m(this,t),a=_(e,o)(...c||[]),S=E(a,r);return S==null?null:b(this,S)}beginInvokeJSFromDotNet(e,t,r,o,c){const l=new Promise(a=>{const S=m(this,r),G=_(t,c)(...S||[]);a(G)});e&&l.then(a=>b(this,[e,!0,E(a,o)])).then(a=>this._dotNetCallDispatcher.endInvokeJSFromDotNet(e,!0,a),a=>this._dotNetCallDispatcher.endInvokeJSFromDotNet(e,!1,JSON.stringify([e,!1,V(a)])))}endInvokeDotNetFromJS(e,t,r){const o=t?m(this,r):new Error(r);this.completePendingCall(parseInt(e,10),t,o)}invokeDotNetStaticMethod(e,t,...r){return this.invokeDotNetMethod(e,t,null,r)}invokeDotNetStaticMethodAsync(e,t,...r){return this.invokeDotNetMethodAsync(e,t,null,r)}invokeDotNetMethod(e,t,r,o){if(this._dotNetCallDispatcher.invokeDotNetFromJS){const c=b(this,o),l=this._dotNetCallDispatcher.invokeDotNetFromJS(e,t,r,c);return l?m(this,l):null}throw new Error("The current dispatcher does not support synchronous calls from JS to .NET. Use invokeDotNetMethodAsync instead.")}invokeDotNetMethodAsync(e,t,r,o){if(e&&r)throw new Error(`For instance method calls, assemblyName should be null. Received '${e}'.`);const c=this._nextAsyncCallId++,l=new Promise((a,S)=>{this._pendingAsyncCalls[c]={resolve:a,reject:S}});try{const a=b(this,o);this._dotNetCallDispatcher.beginInvokeDotNetFromJS(c,e,t,r,a)}catch(a){this.completePendingCall(c,!1,a)}return l}receiveByteArray(e,t){this._byteArraysToBeRevived.set(e,t)}processByteArray(e){const t=this._byteArraysToBeRevived.get(e);return t?(this._byteArraysToBeRevived.delete(e),t):null}supplyDotNetStream(e,t){if(this._pendingDotNetToJSStreams.has(e)){const r=this._pendingDotNetToJSStreams.get(e);this._pendingDotNetToJSStreams.delete(e),r.resolve(t)}else{const r=new P;r.resolve(t),this._pendingDotNetToJSStreams.set(e,r)}}getDotNetStreamPromise(e){let t;if(this._pendingDotNetToJSStreams.has(e))t=this._pendingDotNetToJSStreams.get(e).streamPromise,this._pendingDotNetToJSStreams.delete(e);else{const r=new P;this._pendingDotNetToJSStreams.set(e,r),t=r.streamPromise}return t}completePendingCall(e,t,r){if(!this._pendingAsyncCalls.hasOwnProperty(e))throw new Error(`There is no pending async call with ID ${e}.`);const o=this._pendingAsyncCalls[e];delete this._pendingAsyncCalls[e],t?o.resolve(r):o.reject(r)}}function V(n){return n instanceof Error?`${n.message}
${n.stack}`:n?n.toString():"null"}function _(n,e){const t=g[e];if(t)return t.findFunction(n);throw new Error(`JS object instance with ID ${e} does not exist (has it been disposed?).`)}s.findJSFunction=_;function M(n){delete g[n]}s.disposeJSObjectReferenceById=M;class j{constructor(e,t){this._id=e,this._callDispatcher=t}invokeMethod(e,...t){return this._callDispatcher.invokeDotNetMethod(null,e,this._id,t)}invokeMethodAsync(e,...t){return this._callDispatcher.invokeDotNetMethodAsync(null,e,this._id,t)}dispose(){this._callDispatcher.invokeDotNetMethodAsync(null,"__Dispose",this._id,null).catch(t=>console.error(t))}serializeAsArg(){return{[y]:this._id}}}s.DotNetObject=j,F(function(e,t){if(t&&typeof t=="object"){if(t.hasOwnProperty(y))return new j(t[y],u);if(t.hasOwnProperty(d)){const r=t[d],o=g[r];if(o)return o.getWrappedObject();throw new Error(`JS object instance with Id '${r}' does not exist. It may have been disposed.`)}else if(t.hasOwnProperty(w)){const r=t[w],o=u.processByteArray(r);if(o===void 0)throw new Error(`Byte array index '${r}' does not exist.`);return o}else if(t.hasOwnProperty(k)){const r=t[k],o=u.getDotNetStreamPromise(r);return new W(o)}}return t});class W{constructor(e){this._streamPromise=e}stream(){return this._streamPromise}async arrayBuffer(){return new Response(await this.stream()).arrayBuffer()}}class P{constructor(){this.streamPromise=new Promise((e,t)=>{this.resolve=e,this.reject=t})}}function E(n,e){switch(e){case D.Default:return n;case D.JSObjectReference:return v(n);case D.JSStreamReference:return R(n);case D.JSVoidResult:return null;default:throw new Error(`Invalid JS call result type '${e}'.`)}}let N=0;function b(n,e){N=0,u=n;const t=JSON.stringify(e,q);return u=void 0,t}function q(n,e){if(e instanceof j)return e.serializeAsArg();if(e instanceof Uint8Array){u.getDotNetCallDispatcher().sendByteArray(N,e);const r={[w]:N};return N++,r}return e}}(h.DotNet||(h.DotNet={}));let f;f=h.DotNet.attachDispatcher({sendByteArray:T,beginInvokeDotNetFromJS:B,endInvokeJSFromDotNet:I}),window.external.onReceiveMessage=function(s){var i=JSON.parse(s);switch(i[0]){case"EndInvokeDotNet":{f.endInvokeDotNetFromJS(i[1],i[2],i[3]);break}case"BeginInvokeJS":{f.beginInvokeJSFromDotNet(i[1],i[2],i[3],i[4],i[5]);break}default:console.error(`不支持的消息类型${s}`)}};function B(s,i,d,y,w){window.external.sendMessage(JSON.stringify(["beginInvokeDotNetFromJS",s?s.toString():null,i,d,y||0,w]))}function I(s,i,d){window.external.sendMessage(JSON.stringify(["endInvokeJSFromDotNet",s?s.toString():null,i,d]))}function T(s,i){console.log("sendByteArray")}window.DotNet=h.DotNet,window._registerInstance=(s,i)=>{window[s]=i},window.external.sendMessage(JSON.stringify(["initialized"])),Object.defineProperty(h,Symbol.toStringTag,{value:"Module"})});
